{"projectName":"problem_3_5","totalTests":2,"passed":2,"failed":0,"skipped":0,"coveredLines":82,"missedLines":139,"coveragePercentage":37.1,"moduleStatus":[{"name":"problem_3_5","totalTests":2,"passed":2,"failed":0,"skipped":0,"tests":[{"name":"testFindTopCustomers#\u0027case1\u0027","status":"PASSED"},{"name":"testFindTopCustomers#\u0027case2\u0027","status":"PASSED"}]},{"name":"problem_3_5.backend","totalTests":0,"passed":0,"failed":0,"skipped":0,"tests":[]},{"name":"problem_3_5.customers","totalTests":0,"passed":0,"failed":0,"skipped":0,"tests":[]},{"name":"problem_3_5.sales","totalTests":0,"passed":0,"failed":0,"skipped":0,"tests":[]}],"moduleCoverage":[{"name":"problem_3_5","coveredLines":24,"missedLines":0,"coveragePercentage":100.0,"sourceFiles":[{"name":"main.bal","coveredLines":[14,16,19,21,22,23,24,25,26,27,28,29,33,38,39,40,41,42,43,44,45,46,48,49],"missedLines":[],"coveragePercentage":100.0,"sourceCode":"import ballerina/http;\n// import ballerina/io;\n\nimport problem_3_5.customers;\nimport problem_3_5.sales;\n\ntype Q \"Q1\"|\"Q2\"|\"Q3\"|\"Q4\";\n\ntype Quarter [int, Q];\n\ntype SaleRecord record {\n    readonly string customerId;\n    decimal amount;\n};\n\nfunction findTopXCustomers(Quarter[] quarters, int x) returns customers:Customer[]|error {\n    // final http:Client customerEp \u003d check new (\"http://localhost:8080/customers\");\n    // json customersJson \u003d check customerEp-\u003eget(\"/\");\n    table\u003cSaleRecord\u003e key(customerId) salesTable \u003d table [];\n\n    final http:Client salesEp \u003d check new (\"http://localhost:8080/sales\");\n    foreach Quarter item in quarters {\n        sales:SalesArr salesList \u003d check salesEp-\u003eget(string `?year\u003d${item[0]}\u0026quarter\u003d${item[1]}`);\n        foreach sales:Sales sale in salesList {\n            SaleRecord? entry \u003d salesTable[sale.customerId];\n            if (entry \u003d\u003d ()) {\n                salesTable.add({\n                    \"customerId\": sale.customerId,\n                    \"amount\": sale.amount.clone()\n                });\n            }\n            else {\n                entry.amount +\u003d sale.amount;\n            }\n        }\n    }\n    // customers:Customer[] customerList \u003d check customersJson.cloneWithType(customers:CustomerArr);\n    string[] customerIds \u003d from SaleRecord data in salesTable\n        order by data.amount descending\n        limit x\n        select data.customerId;\n    customers:Customer[] results \u003d [];\n    final http:Client customerEp \u003d check new (\"http://localhost:8080/customers\");\n    foreach string customer in customerIds {\n        customers:Customer customerData \u003d check customerEp-\u003eget(string `/${customer}`);\n        results.push(customerData);\n    }\n    return results;\n}\n\n// public function main() {\n//     io:println(findTopXCustomers([[2022, \"Q1\"], [2021, \"Q3\"]], 3));\n// }\n"}]},{"name":"problem_3_5.backend","coveredLines":51,"missedLines":3,"coveragePercentage":94.44,"sourceFiles":[{"name":"sales_service.bal","coveredLines":[18,23,24,27,29,31,34,35,36,37,38,41,48,49,50,51,52,57,60,61,62,63,64,65,66,69,70,73,74],"missedLines":[53,54],"coveragePercentage":93.55,"sourceCode":"import ballerina/http;\nimport ballerina/io;\nimport ballerina/log;\n\n# Type to represent a quarter\ntype Q \"Q1\"|\"Q2\"|\"Q3\"|\"Q4\";\n\n# Represents total sales per customer\ntype Sales record {|\n    # Customer\u0027s ID\n    readonly string customerId;\n    # Total amount of sales for the customer\n    readonly decimal amount;\n    # Quarter in which these sales were reported\n    readonly Q quarter;\n    # Year for which these sales values belong\n    readonly int year;\n|};\n\ntype SalesResponse record {|\n    *http:Ok;\n\n    map\u003cstring\u003e headers \u003d {\n        \"content-type\": \"application/json\"\n    };\n    Sales[] body;\n|};\n\nisolated service /sales on httpEP {\n\n    private final table\u003cSales\u003e key(customerId, year, quarter) sales \u003d table [];\n\n    function init() returns error? {\n        json data \u003d check io:fileReadJson(\"tests/resources/sales.json\");\n        if data is json[] {\n            foreach json item in data {\n                Sales sales \u003d check item.fromJsonWithType(Sales);\n                self.sales.add(sales);\n            }\n        }\n    }\n\n    # Get total sales\n    #\n    # + year - Query param to specify the year  \n    # + quarter - Optional query param quarter\n    # + return - List of sales\n    isolated resource function get .(int year, string? quarter) returns SalesResponse|http:BadRequest {\n        Q? q \u003d ();\n        if quarter is string {\n            Q|error val \u003d quarter.ensureType(Q);\n            if val is error {\n                log:printWarn(\"Invalid quarter\", q \u003d quarter);\n                return {body: \"Invalid quarter provided\"};\n            }\n\n            q \u003d val;\n        }\n\n        lock {\n            Sales[] filteredSales \u003d from var sales in self.sales\n                where sales.year \u003d\u003d year\n                where quarterMatches(q, sales.quarter)\n                select sales;\n            return \u003cSalesResponse\u003e{\n                body: filteredSales.cloneReadOnly()\n            };\n        }\n    }\n}\n\nisolated function quarterMatches(Q? q1, Q q2) returns boolean {\n    return q1 \u003d\u003d () || q1 \u003d\u003d q2;\n}\n"},{"name":"customer_service.bal","coveredLines":[10,19,22,24,27,28,29,30,31,32,33,36,40,41,42,44,50,51,52,56,58,59],"missedLines":[53],"coveragePercentage":95.65,"sourceCode":"import ballerina/http;\nimport ballerina/io;\n\n# Represents a customer\u0027s address\ntype Address record {|\n    string street;\n    string city;\n    string country;\n    string postalCode;\n|};\n\n# Represents a customer\ntype Customer record {|\n    readonly string id;\n    string firstName;\n    string lastName;\n\n    Address address;\n|};\n\n# Customer service\nisolated service /customers on httpEP {\n\n    private final table\u003cCustomer\u003e key(id) customers \u003d table [];\n\n    function init() returns error? {\n        json data \u003d check io:fileReadJson(\"tests/resources/customers.json\");\n        Customer[] customers \u003d [];\n        if data is json[] {\n            foreach var item in data {\n                Customer c \u003d check item.fromJsonWithType(Customer);\n                customers.push(c);\n                self.customers.add(c);\n            }\n        }\n    }\n\n    # List customers\n    # + return - List of customers\n    isolated resource function get .() returns Customer[] {\n        lock {\n            return self.customers.toArray().cloneReadOnly();\n        }\n    }\n\n    # Get a customer by ID\n    #\n    # + customerId - Customer ID to get\n    # + return - Customer or Not Found\n    isolated resource function get [string byCustomerId]() returns Customer|http:NotFound {\n        lock {\n            if !self.customers.hasKey(byCustomerId) {\n                return {body: \"Invalid customer ID\"};\n            }\n\n            return self.customers.get(byCustomerId).cloneReadOnly();\n        }\n    }\n}\n"}]},{"name":"problem_3_5.customers","coveredLines":2,"missedLines":18,"coveragePercentage":10.0,"sourceFiles":[{"name":"utils.bal","coveredLines":[],"missedLines":[8,9,10,12,14],"coveragePercentage":0.0,"sourceCode":"import ballerina/url;\r\n\r\n# Get Encoded URI for a given value.\r\n#\r\n# + value - Value to be encoded\r\n# + return - Encoded string\r\nisolated function getEncodedUri(anydata value) returns string {\r\n    string|error encoded \u003d url:encode(value.toString(), \"UTF8\");\r\n    if (encoded is string) {\r\n        return encoded;\r\n    } else {\r\n        return value.toString();\r\n    }\r\n}\r\n"},{"name":"types.bal","coveredLines":[9,18],"missedLines":[],"coveragePercentage":100.0,"sourceCode":"public type CustomerArr Customer[];\r\n\r\n# Represents a customer\u0027s address\r\npublic type Address record {\r\n    string street;\r\n    string city;\r\n    string country;\r\n    string postalCode;\r\n};\r\n\r\n# Represents a customer\r\npublic type Customer record {\r\n    string id;\r\n    string firstName;\r\n    string lastName;\r\n    # Represents a customer\u0027s address\r\n    Address address;\r\n};\r\n"},{"name":"client.bal","coveredLines":[],"missedLines":[10,11,12,13,14,19,20,21,22,27,28,29,30],"coveragePercentage":0.0,"sourceCode":"import ballerina/http;\r\n\r\npublic isolated client class Client {\r\n    final http:Client clientEp;\r\n    # Gets invoked to initialize the `connector`.\r\n    #\r\n    # + clientConfig - The configurations to be used when initializing the `connector` \r\n    # + serviceUrl - URL of the target service \r\n    # + return - An error if connector initialization failed \r\n    public isolated function init(string serviceUrl, http:ClientConfiguration clientConfig \u003d  {}) returns error? {\r\n        http:Client httpEp \u003d check new (serviceUrl, clientConfig);\r\n        self.clientEp \u003d httpEp;\r\n        return;\r\n    }\r\n    # List customers\r\n    #\r\n    # + return - Ok \r\n    remote isolated function get() returns Customer[]|error {\r\n        string resourcePath \u003d string `/`;\r\n        Customer[] response \u003d check self.clientEp-\u003eget(resourcePath);\r\n        return response;\r\n    }\r\n    # Get a customer by ID\r\n    #\r\n    # + return - Ok \r\n    remote isolated function getBycustomerid(string byCustomerId) returns Customer|error {\r\n        string resourcePath \u003d string `/${getEncodedUri(byCustomerId)}`;\r\n        Customer response \u003d check self.clientEp-\u003eget(resourcePath);\r\n        return response;\r\n    }\r\n}\r\n"}]},{"name":"problem_3_5.sales","coveredLines":5,"missedLines":118,"coveragePercentage":4.07,"sourceFiles":[{"name":"utils.bal","coveredLines":[8,10,15,24],"missedLines":[31,32,33,34,35,36,37,38,39,40,41,42,43,45,47,48,49,57,58,59,60,61,62,63,64,65,66,68,70,72,73,74,75,76,77,78,80,82,84,85,94,95,96,97,98,99,100,101,103,104,105,106,108,109,110,111,113,114,115,118,119,122,124,125,134,135,136,137,138,139,140,143,144,146,147,150,151,152,159,160,161,163,165,172,173,174,175,176,177,178,179,181,182,183,184,185,186,187,188,190,193,195,197,199,200,201],"coveragePercentage":3.64,"sourceCode":"import ballerina/url;\r\n\r\ntype SimpleBasicType string|boolean|int|float|decimal;\r\n\r\n# Represents encoding mechanism details.\r\ntype Encoding record {\r\n    # Defines how multiple values are delimited\r\n    string style \u003d FORM;\r\n    # Specifies whether arrays and objects should generate as separate fields\r\n    boolean explode \u003d true;\r\n    # Specifies the custom content type\r\n    string contentType?;\r\n    # Specifies the custom headers\r\n    map\u003cany\u003e headers?;\r\n};\r\n\r\nenum EncodingStyle {\r\n    DEEPOBJECT,\r\n    FORM,\r\n    SPACEDELIMITED,\r\n    PIPEDELIMITED\r\n}\r\n\r\nfinal Encoding \u0026 readonly defaultEncoding \u003d {};\r\n\r\n# Serialize the record according to the deepObject style.\r\n#\r\n# + parent - Parent record name\r\n# + anyRecord - Record to be serialized\r\n# + return - Serialized record as a string\r\nisolated function getDeepObjectStyleRequest(string parent, record {} anyRecord) returns string {\r\n    string[] recordArray \u003d [];\r\n    foreach [string, anydata] [key, value] in anyRecord.entries() {\r\n        if value is SimpleBasicType {\r\n            recordArray.push(parent + \"[\" + key + \"]\" + \"\u003d\" + getEncodedUri(value.toString()));\r\n        } else if value is SimpleBasicType[] {\r\n            recordArray.push(getSerializedArray(parent + \"[\" + key + \"]\" + \"[]\", value, DEEPOBJECT, true));\r\n        } else if value is record {} {\r\n            string nextParent \u003d parent + \"[\" + key + \"]\";\r\n            recordArray.push(getDeepObjectStyleRequest(nextParent, value));\r\n        } else if value is record {}[] {\r\n            string nextParent \u003d parent + \"[\" + key + \"]\";\r\n            recordArray.push(getSerializedRecordArray(nextParent, value, DEEPOBJECT));\r\n        }\r\n        recordArray.push(\"\u0026\");\r\n    }\r\n    _ \u003d recordArray.pop();\r\n    return string:\u0027join(\"\", ...recordArray);\r\n}\r\n\r\n# Serialize the record according to the form style.\r\n#\r\n# + parent - Parent record name\r\n# + anyRecord - Record to be serialized\r\n# + explode - Specifies whether arrays and objects should generate separate parameters\r\n# + return - Serialized record as a string\r\nisolated function getFormStyleRequest(string parent, record {} anyRecord, boolean explode \u003d true) returns string {\r\n    string[] recordArray \u003d [];\r\n    if explode {\r\n        foreach [string, anydata] [key, value] in anyRecord.entries() {\r\n            if (value is SimpleBasicType) {\r\n                recordArray.push(key, \"\u003d\", getEncodedUri(value.toString()));\r\n            } else if (value is SimpleBasicType[]) {\r\n                recordArray.push(getSerializedArray(key, value, explode \u003d explode));\r\n            } else if (value is record {}) {\r\n                recordArray.push(getFormStyleRequest(parent, value, explode));\r\n            }\r\n            recordArray.push(\"\u0026\");\r\n        }\r\n        _ \u003d recordArray.pop();\r\n    } else {\r\n        foreach [string, anydata] [key, value] in anyRecord.entries() {\r\n            if (value is SimpleBasicType) {\r\n                recordArray.push(key, \",\", getEncodedUri(value.toString()));\r\n            } else if (value is SimpleBasicType[]) {\r\n                recordArray.push(getSerializedArray(key, value, explode \u003d false));\r\n            } else if (value is record {}) {\r\n                recordArray.push(getFormStyleRequest(parent, value, explode));\r\n            }\r\n            recordArray.push(\",\");\r\n        }\r\n        _ \u003d recordArray.pop();\r\n    }\r\n    return string:\u0027join(\"\", ...recordArray);\r\n}\r\n\r\n# Serialize arrays.\r\n#\r\n# + arrayName - Name of the field with arrays\r\n# + anyArray - Array to be serialized\r\n# + style - Defines how multiple values are delimited\r\n# + explode - Specifies whether arrays and objects should generate separate parameters\r\n# + return - Serialized array as a string\r\nisolated function getSerializedArray(string arrayName, anydata[] anyArray, string style \u003d \"form\", boolean explode \u003d true) returns string {\r\n    string key \u003d arrayName;\r\n    string[] arrayValues \u003d [];\r\n    if (anyArray.length() \u003e 0) {\r\n        if (style \u003d\u003d FORM \u0026\u0026 !explode) {\r\n            arrayValues.push(key, \"\u003d\");\r\n            foreach anydata i in anyArray {\r\n                arrayValues.push(getEncodedUri(i.toString()), \",\");\r\n            }\r\n        } else if (style \u003d\u003d SPACEDELIMITED \u0026\u0026 !explode) {\r\n            arrayValues.push(key, \"\u003d\");\r\n            foreach anydata i in anyArray {\r\n                arrayValues.push(getEncodedUri(i.toString()), \"%20\");\r\n            }\r\n        } else if (style \u003d\u003d PIPEDELIMITED \u0026\u0026 !explode) {\r\n            arrayValues.push(key, \"\u003d\");\r\n            foreach anydata i in anyArray {\r\n                arrayValues.push(getEncodedUri(i.toString()), \"|\");\r\n            }\r\n        } else if (style \u003d\u003d DEEPOBJECT) {\r\n            foreach anydata i in anyArray {\r\n                arrayValues.push(key, \"[]\", \"\u003d\", getEncodedUri(i.toString()), \"\u0026\");\r\n            }\r\n        } else {\r\n            foreach anydata i in anyArray {\r\n                arrayValues.push(key, \"\u003d\", getEncodedUri(i.toString()), \"\u0026\");\r\n            }\r\n        }\r\n        _ \u003d arrayValues.pop();\r\n    }\r\n    return string:\u0027join(\"\", ...arrayValues);\r\n}\r\n\r\n# Serialize the array of records according to the form style.\r\n#\r\n# + parent - Parent record name\r\n# + value - Array of records to be serialized\r\n# + style - Defines how multiple values are delimited\r\n# + explode - Specifies whether arrays and objects should generate separate parameters\r\n# + return - Serialized record as a string\r\nisolated function getSerializedRecordArray(string parent, record {}[] value, string style \u003d FORM, boolean explode \u003d true) returns string {\r\n    string[] serializedArray \u003d [];\r\n    if style \u003d\u003d DEEPOBJECT {\r\n        int arayIndex \u003d 0;\r\n        foreach var recordItem in value {\r\n            serializedArray.push(getDeepObjectStyleRequest(parent + \"[\" + arayIndex.toString() + \"]\", recordItem), \"\u0026\");\r\n            arayIndex \u003d arayIndex + 1;\r\n        }\r\n    } else {\r\n        if (!explode) {\r\n            serializedArray.push(parent, \"\u003d\");\r\n        }\r\n        foreach var recordItem in value {\r\n            serializedArray.push(getFormStyleRequest(parent, recordItem, explode), \",\");\r\n        }\r\n    }\r\n    _ \u003d serializedArray.pop();\r\n    return string:\u0027join(\"\", ...serializedArray);\r\n}\r\n\r\n# Get Encoded URI for a given value.\r\n#\r\n# + value - Value to be encoded\r\n# + return - Encoded string\r\nisolated function getEncodedUri(anydata value) returns string {\r\n    string|error encoded \u003d url:encode(value.toString(), \"UTF8\");\r\n    if (encoded is string) {\r\n        return encoded;\r\n    } else {\r\n        return value.toString();\r\n    }\r\n}\r\n\r\n# Generate query path with query parameter.\r\n#\r\n# + queryParam - Query parameter map\r\n# + encodingMap - Details on serialization mechanism\r\n# + return - Returns generated Path or error at failure of client initialization\r\nisolated function getPathForQueryParam(map\u003canydata\u003e queryParam, map\u003cEncoding\u003e encodingMap \u003d {}) returns string|error {\r\n    string[] param \u003d [];\r\n    if (queryParam.length() \u003e 0) {\r\n        param.push(\"?\");\r\n        foreach var [key, value] in queryParam.entries() {\r\n            if value is () {\r\n                _ \u003d queryParam.remove(key);\r\n                continue;\r\n            }\r\n            Encoding encodingData \u003d encodingMap.hasKey(key) ? encodingMap.get(key) : defaultEncoding;\r\n            if (value is SimpleBasicType) {\r\n                param.push(key, \"\u003d\", getEncodedUri(value.toString()));\r\n            } else if (value is SimpleBasicType[]) {\r\n                param.push(getSerializedArray(key, value, encodingData.style, encodingData.explode));\r\n            } else if (value is record {}) {\r\n                if (encodingData.style \u003d\u003d DEEPOBJECT) {\r\n                    param.push(getDeepObjectStyleRequest(key, value));\r\n                } else {\r\n                    param.push(getFormStyleRequest(key, value, encodingData.explode));\r\n                }\r\n            } else {\r\n                param.push(key, \"\u003d\", value.toString());\r\n            }\r\n            param.push(\"\u0026\");\r\n        }\r\n        _ \u003d param.pop();\r\n    }\r\n    string restOfPath \u003d string:\u0027join(\"\", ...param);\r\n    return restOfPath;\r\n}\r\n"},{"name":"client.bal","coveredLines":[],"missedLines":[10,11,12,13,14,20,21,22,23,24,25,26],"coveragePercentage":0.0,"sourceCode":"import ballerina/http;\r\n\r\npublic isolated client class Client {\r\n    final http:Client clientEp;\r\n    # Gets invoked to initialize the `connector`.\r\n    #\r\n    # + clientConfig - The configurations to be used when initializing the `connector` \r\n    # + serviceUrl - URL of the target service \r\n    # + return - An error if connector initialization failed \r\n    public isolated function init(string serviceUrl, http:ClientConfiguration clientConfig \u003d  {}) returns error? {\r\n        http:Client httpEp \u003d check new (serviceUrl, clientConfig);\r\n        self.clientEp \u003d httpEp;\r\n        return;\r\n    }\r\n    # Get total sales\r\n    #\r\n    # + year - Query param to specify the year   \r\n    # + quarter - Optional query param quarter \r\n    # + return - Ok \r\n    remote isolated function get(int year, string? quarter \u003d ()) returns Sales[]|error {\r\n        string resourcePath \u003d string `/`;\r\n        map\u003canydata\u003e queryParam \u003d {\"year\": year, \"quarter\": quarter};\r\n        resourcePath \u003d resourcePath + check getPathForQueryParam(queryParam);\r\n        Sales[] response \u003d check self.clientEp-\u003eget(resourcePath);\r\n        return response;\r\n    }\r\n}\r\n"},{"name":"types.bal","coveredLines":[13],"missedLines":[],"coveragePercentage":100.0,"sourceCode":"public type SalesArr Sales[];\r\n\r\n# Represents total sales per customer\r\npublic type Sales record {\r\n    # Customer\u0027s ID\r\n    string customerId;\r\n    # Total amount of sales for the customer\r\n    decimal amount;\r\n    # Quarter in which these sales were reported\r\n    string quarter;\r\n    # Year for which these sales values belong\r\n    int year;\r\n};\r\n"}]}]}